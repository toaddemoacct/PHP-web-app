CREATE OR REPLACE PACKAGE BODY DELL_DEV."Q##OW_CALC_ORDER_COST_1"
/*
| Automated Test Package for OW_CALC_ORDER_COST
|
| Generated by Dell Code Tester for Oracle.
| Visit the user community at http://unittest.inside.dell.com/index.jspa
| Generated on 2013-11-11T08:37:17
*/
IS
/* Global variables for dyn TC execution, timings and SQL status. */
c_two_quotes CONSTANT CHAR(1) := '''';
Q##start_time NUMBER;
Q##end_time NUMBER;
Q##sql_rowcount PLS_INTEGER; -- for SQL%ROWCOUNT
g_pre_ut_hook_exists BOOLEAN := qu_config.my_codetester_exists ('PRE_UNIT_TEST');
g_post_ut_hook_exists BOOLEAN := qu_config.my_codetester_exists ('POST_UNIT_TEST');
g_pre_tc_hook_exists BOOLEAN := qu_config.my_codetester_exists ('PRE_TEST_CASE');
g_post_tc_hook_exists BOOLEAN := qu_config.my_codetester_exists ('POST_TEST_CASE');
PROCEDURE qcto#report_result  (
      result_guid_in   IN   VARCHAR2
    , status_in        IN   VARCHAR2
    , description_in   IN   VARCHAR2
   )
IS
BEGIN
   IF status_in = 'RUNTIME-ERROR' THEN
      qu_runtime.trace ('runtime_error running test for guid ' || result_guid_in, SQLERRM, TRUE);
      qu_runtime.trace ('runtime_error running test description', description_in, TRUE);
   END IF;
   qu_result_xp.set_result (
      result_universal_id_in => result_guid_in
    , harness_guid_in => qu_test.current_harness_guid
    , result_status_in => status_in
    , description_in => description_in);
END qcto#report_result;
PROCEDURE qcto#report_result  (
      result_guid_in   IN   VARCHAR2
    , status_in        IN   VARCHAR2
    , description_in   IN   VARCHAR2
    , universal_id_out OUT VARCHAR2
   )
IS
BEGIN
   IF status_in = 'RUNTIME-ERROR' THEN
      qu_runtime.trace ('runtime_error running test for guid ' || result_guid_in, SQLERRM, TRUE);
      qu_runtime.trace ('runtime_error running test description', description_in, TRUE);
   END IF;
   qu_result_xp.set_result (
      result_universal_id_in => result_guid_in
    , harness_guid_in => qu_test.current_harness_guid
    , result_status_in => status_in
    , description_in => description_in
    , universal_id_out => universal_id_out);
END qcto#report_result;FUNCTION qcto#error_info RETURN VARCHAR2 IS
   l_stack VARCHAR2(32767);
BEGIN
   BEGIN
      EXECUTE IMMEDIATE
        'BEGIN :val := SUBSTR (''PL/SQL Error Backtrace: ''
             || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000); END;'
      USING OUT l_stack;
   EXCEPTION
      WHEN OTHERS THEN l_stack := DBMS_UTILITY.FORMAT_CALL_STACK;
   END;
   RETURN SUBSTR (DBMS_UTILITY.FORMAT_ERROR_STACK || CHR(10) || l_stack, 1, 4000);
END qcto#error_info;
PROCEDURE qcto#assert_this (
   outcome_guid_in   IN   VARCHAR2
 , msg_in            IN   VARCHAR2
 , check_this_in     IN   BOOLEAN
 , null_ok_in        IN   BOOLEAN := FALSE
 , raise_exc_in      IN   BOOLEAN := FALSE
)
IS
BEGIN
   IF NOT check_this_in OR ( check_this_in IS NULL AND NOT null_ok_in )
   THEN
      qcto#report_result ( outcome_guid_in, 'FAILURE', msg_in );
      IF raise_exc_in THEN RAISE PROGRAM_ERROR; END IF;
   ELSE
      qcto#report_result ( outcome_guid_in, 'SUCCESS', msg_in );
   END IF;
END qcto#assert_this;
PROCEDURE qcto#assert_this (
   outcome_guid_in   IN   VARCHAR2
 , msg_in            IN   VARCHAR2
 , check_this_in     IN   BOOLEAN
 , null_ok_in        IN   BOOLEAN := FALSE
 , raise_exc_in      IN   BOOLEAN := FALSE
 , universal_id_out   OUT  VARCHAR2
)
IS
BEGIN
   IF NOT check_this_in OR ( check_this_in IS NULL AND NOT null_ok_in )
   THEN
      qcto#report_result ( outcome_guid_in, 'FAILURE', msg_in, universal_id_out );
      IF raise_exc_in THEN RAISE PROGRAM_ERROR; END IF;
   ELSE
      qcto#report_result ( outcome_guid_in, 'SUCCESS', msg_in, universal_id_out );
   END IF;
END qcto#assert_this;
PROCEDURE qcto#assert_null (
   outcome_guid_in   IN   VARCHAR2
 , is_null_in        IN   BOOLEAN
 , check_type_in     IN   VARCHAR2
 , raise_exc_in      IN   BOOLEAN DEFAULT FALSE
 , add_to_message_in IN   VARCHAR2 DEFAULT NULL
)
IS
   l_message VARCHAR2(32767);
BEGIN
   l_message :=
      CASE WHEN is_null_in THEN 'Value is NULL' ELSE 'Value is NOT NULL' END
      ||
      CASE WHEN add_to_message_in IS NOT NULL THEN ': ' || SUBSTR (add_to_message_in, 1, 32000) ELSE NULL END
      ;
   qcto#report_result ( outcome_guid_in
                      , CASE
                           WHEN is_null_in AND check_type_in = 'IS-NULL' THEN 'SUCCESS'
                           WHEN NOT is_null_in AND check_type_in = 'NOT-IS-NULL' THEN 'SUCCESS'
                           ELSE 'FAILURE'
                        END
                      , l_message
                      );
   IF raise_exc_in
   THEN
      RAISE PROGRAM_ERROR;
   END IF;
END qcto#assert_null;

PROCEDURE qcto#assert_null (
   outcome_guid_in   IN   VARCHAR2
 , is_null_in        IN   BOOLEAN
 , check_type_in     IN   VARCHAR2
 , raise_exc_in      IN   BOOLEAN
 , add_to_message_in IN   BOOLEAN
)
IS
BEGIN
   qcto#assert_null (
   outcome_guid_in
 , is_null_in
 , check_type_in
 , raise_exc_in
 , QU_CONFIG.BOOL2VC ( add_to_message_in )
);
END qcto#assert_null;

FUNCTION qcto#hash (string_in in VARCHAR2) RETURN PLS_INTEGER
IS BEGIN
   RETURN DBMS_UTILITY.get_hash_value (string_in, 1, 2 ** 31 - 1);
END qcto#hash;

FUNCTION qcto#skip_tc (guid_in IN VARCHAR2) RETURN BOOLEAN
IS
   /* TRUE if list is inclusive, FALSE otherwise. */
   l_including boolean := Q##skip_tc_execution('INCLUDE');
BEGIN
   IF Q##skip_tc_execution.COUNT <= 1 THEN
      /* Only the default INCLUDE indicator row is present. */
      RETURN FALSE;
   ELSIF Q##skip_tc_execution.EXISTS (guid_in) THEN
      /* User specified this element, so skip it if non-inclusive list. */
      RETURN NOT l_including;
   ELSE
      /* Guid was not among those specified. If list is inclusive,
         then we skip this. If exclusive, then we include it. */
      RETURN l_including;
   END IF;
END qcto#skip_tc;

/* Set of fp_to_string functions */
FUNCTION fp_to_string(value_in IN BINARY_DOUBLE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN BINARY_FLOAT)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN INTERVAL DAY TO SECOND)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN INTERVAL YEAR TO MONTH)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN TIMESTAMP WITH LOCAL TIME ZONE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS.FF TZR TZD') END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN TIMESTAMP WITH TIME ZONE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS.FF TZR TZD') END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN CLOB)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE CASE WHEN LENGTH(value_in) <= 450 THEN value_in ELSE SUBSTR(value_in, 1, 450) || '...' END END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN TIMESTAMP)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS.FF') END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN DATE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS') END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN BINARY_INTEGER)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN VARCHAR2)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE CASE WHEN LENGTH(value_in) <= 450 THEN value_in ELSE SUBSTR(value_in, 1, 450) || '...' END END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN NUMBER)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END fp_to_string;

FUNCTION fp_to_string(value_in IN BOOLEAN)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE CASE value_in WHEN TRUE THEN 'TRUE' WHEN FALSE THEN 'FALSE' END END;
   RETURN l_string;
END fp_to_string;

/* Set of exp_to_string functions */
FUNCTION exp_to_string(value_in IN BINARY_DOUBLE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN BINARY_FLOAT)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
   BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN INTERVAL DAY TO SECOND)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN INTERVAL YEAR TO MONTH)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN TIMESTAMP WITH LOCAL TIME ZONE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS.FF TZR TZD') END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN TIMESTAMP WITH TIME ZONE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS.FF TZR TZD') END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN CLOB)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE CASE WHEN LENGTH(value_in) <= 450 THEN value_in ELSE SUBSTR(value_in, 1, 450) || '...' END END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN TIMESTAMP)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS.FF') END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN DATE)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in, 'YYYY-MM-DD HH24:MI:SS') END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN BINARY_INTEGER)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN VARCHAR2)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE CASE WHEN LENGTH(value_in) <= 450 THEN value_in ELSE SUBSTR(value_in, 1, 450) || '...' END END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN NUMBER)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE TO_CHAR(value_in) END;
   RETURN l_string;
END exp_to_string;

FUNCTION exp_to_string(value_in IN BOOLEAN)
   RETURN VARCHAR2
IS
   l_string VARCHAR2(32767);
BEGIN
   l_string := CASE WHEN value_in IS NULL THEN NULL ELSE CASE value_in WHEN TRUE THEN 'TRUE' WHEN FALSE THEN 'FALSE' END END;
   RETURN l_string;
END exp_to_string;
   PROCEDURE Q##setup IS
   BEGIN
   NULL; END Q##setup;
   PROCEDURE Q##teardown IS
   BEGIN
   NULL; END Q##teardown;
   PROCEDURE Q##OW_CALC_ORDER_COST
   /* Unit test procedure for OW_CALC_ORDER_COST
Unit test for "OW_CALC_ORDER_COST"
 */
   IS
   PROCEDURE Q##_NEW_TEST_CASE_NAME_
   /* Test case name: <NEW TEST CASE NAME> */
   IS
   /* 1. Call generate_declaration LK 2.1.1*/
   /* 1.1 Call gen_local_vars LK 2.1.1*/
   /* 1.1.1 Declare return variable for function. LK 2.1.1*/
   /* The return value of the function */
   Q##FUNCTION_RETURN_VALUE NUMBER;
   gtc_tore_down BOOLEAN;
   tc_result_guid VARCHAR2(32767);
   /* 1.1.2. Call gen_declares_for_parameters LK 2.1.1*/
    /* Declarations for parameters and OT attributes if present*/
   I_P_ID NUMBER;
   I_QTY_WANTED NUMBER;
   /* 1.1.3. Call gen_declare_for_ot_instance LK 2.1.1*/
   /* Variables needed for dynamic test case execution */
   l_min_count PLS_INTEGER;
   /* Needed for inputs to program */
   /* Arrays needed for multiple outcomes from program */
   /* 2. Call generate_setup LK 2.1.1*/
         PROCEDURE setup IS
         BEGIN
         gtc_tore_down := FALSE;
         IF qu_result_xp.rolling_back_before ('Y') THEN ROLLBACK;  END IF;

         END setup;
         /* 3. Call generate_teardown LK 2.1.1*/
         PROCEDURE teardown IS
         BEGIN
         IF gtc_tore_down THEN NULL; ELSE gtc_tore_down := TRUE;
         /* Input teardown, including individual OT attribute teardown */

         IF qu_result_xp.rolling_back_after ('Y') THEN ROLLBACK;  END IF;
          END IF; END teardown;
         /* 4. Call generate_set_in_values LK 2.1.1*/
         PROCEDURE set_in_values
         IS BEGIN
         /* Assign values to inputs for program execution. */
i_P_ID := '100870';

i_QTY_WANTED := '5';

          NULL;
         END set_in_values;
         /* 5. Call generate_program_call LK 2.1.1*/

PROCEDURE call_the_program IS
PROCEDURE add_input_values (tc_result_guid_in IN VARCHAR2) IS BEGIN NULL;
qu_result_xp.add_input (tc_result_guid_in, '{77AF312D-8AA6-4DD1-9D50-9A197516BDE8}', 'P_ID', i_P_ID);
qu_result_xp.save_argval ('P_ID', i_P_ID);
qu_result_xp.add_input (tc_result_guid_in, '{0C4BC2A8-6C9F-4883-AF74-7699A0EA29EE}', 'QTY_WANTED', i_QTY_WANTED);
qu_result_xp.save_argval ('QTY_WANTED', i_QTY_WANTED);
 END add_input_values;
PROCEDURE save_outarg_values (tc_result_guid_in IN VARCHAR2) IS BEGIN
  /* In case there are no scalar OUT arguments. */ NULL;
/* Return */ qu_result_xp.save_argval ('RETURN', Q##FUNCTION_RETURN_VALUE);
/* Return */ qu_result_xp.add_outarg (tc_result_guid_in, '{65664993-28C3-4554-85F0-74DD6AB4F01B}', 'RETURN', Q##FUNCTION_RETURN_VALUE, gen_type_in => 'TEST CODE');
 END save_outarg_values;
PROCEDURE check_non_exc_outcomes
IS
PROCEDURE check_oc_141979085 IS
/* Declarations for Outcomes */
E_FUNCTION_RETURN_VALUE NUMBER;
BEGIN
  /* Outcome Reference Information:
     Unit Test: OW_CALC_ORDER_COST (Function)-{5F7B7519-96E8-4553-9700-1556D0D546E5}
     Test Case: <NEW TEST CASE NAME>-{060A4235-9E16-45A7-8769-7B3B7789F9A4}
     Outcome: Scalar is equal to the expected value?-{4CC5869A-8581-4CF0-83FF-0D2349FF85CB} */
 qu_result_xp.set_current_oc ('{4CC5869A-8581-4CF0-83FF-0D2349FF85CB}'); e_Function_return_value := '1779.95';
/* Copy OUT argument to variable for use in assertion code. */
/*NAMEDNOTREF*/Q##function_return_value := Q##FUNCTION_RETURN_VALUE;
 /* Assertion code for outcome {4CC5869A-8581-4CF0-83FF-0D2349FF85CB} */
DECLARE
   cv sys_refcursor;
   l_fp_value NUMBER ;
   l_exp_value NUMBER := e_Function_return_value;

      l_result BOOLEAN DEFAULT TRUE;
   l_message VARCHAR2(32767);
   l_dummy PLS_INTEGER;
   FUNCTION fp_to_string (value_in IN NUMBER) RETURN VARCHAR2 IS l_string VARCHAR2(32767); BEGIN l_string := CASE WHEN value_in IS NULL THEN NULL ELSE  TO_CHAR ( value_in ) END; RETURN l_string; END fp_to_string;
   FUNCTION exp_to_string (value_in IN NUMBER) RETURN VARCHAR2 IS l_string VARCHAR2(32767); BEGIN l_string := CASE WHEN value_in IS NULL THEN NULL ELSE  TO_CHAR ( value_in ) END; RETURN l_string; END exp_to_string;
BEGIN
   l_fp_value := Q##function_return_value;





   IF    l_fp_value IS NULL OR l_exp_value IS NULL
   THEN
      l_result :=  l_fp_value IS NULL AND l_exp_value IS NULL;
   ELSE
      l_result := l_fp_value = l_exp_value;
      IF l_result IS NULL THEN l_result := FALSE; END IF;
   END IF;





   l_message :=
        ' From Program Value of '
      || CASE WHEN l_fp_value IS NULL THEN 'NULL' ELSE '"' || fp_to_string(l_fp_value) || '" ' END
      || CASE WHEN l_result THEN '=' ELSE NVL('<>', 'NOT ' || '=') END
      || ' Expected Value '
      || CASE WHEN l_exp_value IS NULL THEN 'NULL' ELSE '"' || exp_to_string(l_exp_value) || '"' END;
   qcto#assert_this ( outcome_guid_in => qu_result_xp.current_outcome()
        , msg_in => l_message
        , check_this_in => l_result
        , null_ok_in    => FALSE
        , raise_exc_in  => FALSE
        );
EXCEPTION
   WHEN OTHERS THEN
      -- Report the failure.
      qcto#report_result (
          result_guid_in => qu_result_xp.current_outcome()
         ,status_in => 'RUNTIME-ERROR'
         ,description_in => qcto#error_info
      );
END;
END check_oc_141979085;
BEGIN
check_oc_141979085();
NULL;/* Ensure compilability */
END check_non_exc_outcomes;
BEGIN
tc_result_guid := qu_result_xp.guid_for_key_info (result_guid_in =>qu_result_xp.current_test_case (), iteration_in => qu_result_xp.c_template_iteration);
add_input_values (tc_result_guid);
IF qu_result_xp.profiling_enabled THEN
qu_result_xp.start_profiling (unit_name_in => 'OW_CALC_ORDER_COST', test_case_guid_in => qu_result_xp.current_test_case, test_case_name_in => '<NEW TEST CASE NAME>', test_case_iteration_in => 0);
END IF;
  /* Capture start time. */
Q##start_time := DBMS_UTILITY.GET_TIME;
Q##FUNCTION_RETURN_VALUE :=
"DELL_DEV"."OW_CALC_ORDER_COST"(
P_ID => i_P_ID
,QTY_WANTED => i_QTY_WANTED
);
/* START POST EXECUTION CONTENT */
IF qu_result_xp.profiling_enabled THEN qu_result_xp.stop_profiling (done_with_in => qu_result_xp.c_this_test_case); END IF;
Q##end_time := DBMS_UTILITY.GET_TIME;
save_outarg_values(tc_result_guid);
  /* Get numbers of rows modified by last SQL statement. */
Q##sql_rowcount := SQL%ROWCOUNT;
/* END POST EXECUTION CONTENT */
check_non_exc_outcomes( );
EXCEPTION
WHEN OTHERS THEN
teardown;qcto#report_result(result_guid_in => qu_result_xp.current_test_case, status_in => 'RUNTIME-ERROR', description_in => qcto#error_info);
END call_the_program;
         /* 6. Call generate_exec_section LK 2.1.1*/
         BEGIN
         qu_result_xp.set_current_tc ('{060A4235-9E16-45A7-8769-7B3B7789F9A4}');
         if g_pre_tc_hook_exists
               then
                  QU_CONFIG.MY_CODETESTER_HOOK ('PRE_TEST_CASE','DELL_DEV','DELL_DEV','OW_CALC_ORDER_COST','Q##OW_CALC_ORDER_COST_1','OW_CALC_ORDER_COST','','<NEW TEST CASE NAME>'); end if;
         qu_result_xp.mark_start (qu_result_xp.current_test_case);
         setup();
         set_in_values;
         call_the_program ();
         teardown;
         if g_post_tc_hook_exists
               then
                  QU_CONFIG.MY_CODETESTER_HOOK ('POST_TEST_CASE','DELL_DEV','DELL_DEV','OW_CALC_ORDER_COST','Q##OW_CALC_ORDER_COST_1','OW_CALC_ORDER_COST','','<NEW TEST CASE NAME>'); end if;
         qu_result_xp.mark_end (qu_result_xp.current_test_case);
         /* 7. Call generate_end_of_program LK 2.1.1*/
         /* Exception outcomes trapping for incorrect invocation of subprogram. */
EXCEPTION
WHEN OTHERS THEN
teardown;qcto#report_result(result_guid_in => qu_result_xp.current_test_case, status_in => 'RUNTIME-ERROR', description_in => qcto#error_info);
         END Q##_NEW_TEST_CASE_NAME_;
         BEGIN
         qu_result_xp.mark_start ('{5F7B7519-96E8-4553-9700-1556D0D546E5}');
         qu_result_xp.set_current_ut ('{5F7B7519-96E8-4553-9700-1556D0D546E5}');
         if g_pre_ut_hook_exists
               then
                  QU_CONFIG.MY_CODETESTER_HOOK ('PRE_UNIT_TEST','DELL_DEV','DELL_DEV','OW_CALC_ORDER_COST','Q##OW_CALC_ORDER_COST_1','OW_CALC_ORDER_COST',''); end if;
         DECLARE
   TYPE order_t IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;
   l_exec_order order_t;
         PROCEDURE run_one (seq_in IN PLS_INTEGER) IS BEGIN
         CASE seq_in
         WHEN 1 THEN  IF NOT qcto#skip_tc ('{060A4235-9E16-45A7-8769-7B3B7789F9A4}') THEN Q##_NEW_TEST_CASE_NAME_; END IF;
         END CASE; END run_one; BEGIN
         /* Alphabetical execution order, just copy to driver collection. */
         l_exec_order(1) := 1;
         FOR indx IN 1 .. l_exec_order.COUNT LOOP run_one (l_exec_order(indx)); END LOOP;
         END;
         IF qu_result_xp.profiling_enabled THEN qu_result_xp.stop_profiling (done_with_in => qu_result_xp.c_this_test_case); END IF;
         if g_post_ut_hook_exists
               then
                  QU_CONFIG.MY_CODETESTER_HOOK ('POST_UNIT_TEST','DELL_DEV','DELL_DEV','OW_CALC_ORDER_COST','Q##OW_CALC_ORDER_COST_1','OW_CALC_ORDER_COST',''); end if;
         qu_result_xp.mark_end ('{5F7B7519-96E8-4553-9700-1556D0D546E5}');
         EXCEPTION WHEN OTHERS THEN
         IF qu_result_xp.profiling_enabled THEN qu_result_xp.stop_profiling (done_with_in => qu_result_xp.c_this_test_case); END IF;
         qcto#report_result (result_guid_in => qu_result_xp.current_unit_test,status_in => 'RUNTIME-ERROR',description_in => qcto#error_info);

         IF qu_result_xp.rolling_back_after () THEN ROLLBACK;  END IF;
         END Q##OW_CALC_ORDER_COST;
         END "Q##OW_CALC_ORDER_COST_1";
/
